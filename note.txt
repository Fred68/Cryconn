##############################################################################
#
#		DA FARE
#
#
#	v	Fatto
#	.	Non fatto
#	->	Da fare
#	?	Verificare
#	x	Annullato
#	**	In corso
#
#
##############################################################################


	IMPORTANTE:
	JS non è sicuro. Un attacco MIM potrebbe alterare il codice js e intercettare la chiave AES
	con la quale poi leggere i dati sul server.
	USARE CHIAVE ASIMMETRICA (RSA)
	Con la chiave asimmetrica, il server scambia ogni volta una nuova chiave AES
	La chiave AES è valida per una sola sessione (o per un tempo limitato)
	ma permette scambio dati valoce (RSA è lento)



	v		Eseguire ShowPage soltanto una volta (al login e dopo il login). Gli altri comandi vanno eseguiti attraverso xlmhttprequest
	
		?	Aggiungere controllo del timeout !!!
	
		?	Correggere messaggi refresh, per cancellare messaggio ed errore precedenti.
	
		?	Separare i messaggi del refresh, in campo html diverso da quello del messaggio, se no lo cancella subito
	
		?	Ad ogni refresh, CONTROLLARE IL DATABASE, se l'utente è connesso. 
	
		?	Prima di eseguire il Clear Logged, verificare che abbia raggiunto il timeout.
	
		?	Attivare e disattivare il timer di refresh se login effettuato o no. Fatto in base a comando in risposta del server.
	
	.		Aggiungere poi un secondo timer per refresh locale della pagina.
			Il timer lungo verifica la connessione
			Il timer corto interroga il server se ci sono messaggi.
			Coda di messaggi: da implementare in futuro
	
	.		Rifare programma con coda di messaggi e stato.
			Il client chiede se ci sono messaggi in coda, con un timer + un flag, se un messaggio deve esser controllato subito.
			Il server ha una coda di messaggi
			
	v		Usare direttamente include 'pagine.php' per mostrarla, senza dover leggere il file
	
	.		ATTENZIONE: RIPULIRE (sanitize) i POST[] prima di utilizzarli, contro sql injection.
	
	.		Vedere cosa fare con sha1(password), dovrebbe contenere solo caratteri alfanumerici
			
	.		Spostare tutti i nomi delle variabili di sessione nelle costanti
	
	.		Completare script.php con caricamento script da cdn o locale
	
	v		Inserire la chiave AES e salvarla in locale.
			Usare inizialmente localStorage (insicuro !!!) o, meglio, sessionStorage (non molto sicuro)
			
	.		Studiare due coppie di chiavi asimmetriche, per l'invio sicure della chiave aes
			Messaggi da client js a server php:
				js chiede a php una chiave
				php genera chiave pubblica e privata.
				Invia chiave pubblica a js
				js crittografa il messaggio con chiave pubblica e lo invia
				php decifra con chiave privata
			Messaggi da server a client:
				php chiede a js una chiave
				js genera chiave pubblica e privata
				js invia chiave pubblica a php
				php prepara il messaggio (la chiave aes + altri dati eventuali, timestamp, session ecc...)
				php crittografa il messaggio con la chiave pubblica e lo invia
				js decifra il messaggio con la chiave privata
	v		Crittografate con chiave pubblica la chiave AES inviata da server a Client.
				js genera coppia di chiavi puk e prk.
				js Invia la puk a php
				php genera la chiave aes e la unisce al sid
				php crittografa aes+sid con la puk e la invia al client
				js decifra aes+sid con la prk.
		
	.		Studiare modo per evitare di generare le chiavi in JS, e per il solo scambio sicuro della chiave aes.
			Sistema 1:
			Non sufficiente, manca l'autenticazione, un MITM potrebbe alterare il codice js e sostituire messaggi.
				js chiede a php una chiave
				php genera chiave pubblica e privata.
				Invia chiave pubblica a js
				js prepara un messaggio contenente una chiave aes temporanea
				js crittografa il messaggio con la chiave pubblica e la invia
				php decifra il messaggio con chiave privata ed estrae l'aes temporaneo
				php genera l'aes di sessione, lo crittografa con la chiave temporanea e la invia.
				NON VA BENE: manca l'autenticazione, che i messaggi da client non siano quelli di un MITM.
				JS non deve generare una chiave aes temporanea, ma una coppia di chiavi pubblica e privata.
			Sistema 2:
			Troppo complesso
				js chiede a php la chiave aes
				php genera le chiavi del server pubblica Spu e privata Spr
				Invia chiave pubblica Spu a js
				js riceve la chiave pubblica Spu
				js genera le chiavi del Client pubblica Cpu e privata Cpr
				js prepara un messaggio con la chiave Cpu 
				js crittografa il messaggio con la Spu, e lo invia
				php decifra il messaggio con la chiave Spr
				php estrae la chiave Cpu
				php genera la chiave AES di sessione
				php prepara una messaggio con la chiave AES generata
				php crittografa il messaggio con la chiave Cpu e lo invia
				js riceve il messaggio e lo decifra con la Cpr
				estrae la chaive AES e la memorizza.
				NO, troppo complesso !
			Studiare sistema con autenticazione
				Server e Client devono scambiarsi, prima e con un canale differente, due coppie di chiavi pubblica e privata.
				Poi possono usare queste chiavi per scambiarsi la chiave aes oppure per autenticare i messaggi.

		->		Librerie:
				php: vd. esempi in calce	
				
	.		Successivamente, non usare localStorage o sessionStorage.
			Provare download link e Blob per salvare i dati in un file locale 
			Registrare in localStorage nome completo del file. Poi:
			Ripristinare il nome completo del file.
			Se nullo: chiederlo con un prompt.
			Leggere il contenuto del file.
			Se manca: richiedere dall'inizio.
	
##############################################################################


<?php
$pkGenerate = openssl_pkey_new(array('private_key_bits' => 2048,'private_key_type' => OPENSSL_KEYTYPE_RSA));	// generate 2048-bit RSA key
openssl_pkey_export($pkGenerate,$pkGeneratePrivate); // NOTE: second argument is passed by reference	// get the private key
$pkGenerateDetails = openssl_pkey_get_details($pkGenerate);		// get the...
$pkGeneratePublic = $pkGenerateDetails['key'];					// ...public key
openssl_pkey_free($pkGenerate);									// free resources
// fetch/import public key from PEM formatted string $pkGeneratePrivate now is PEM formatted... this is an alternative method from the public retrieval in previous
$pkImport = openssl_pkey_get_private($pkGeneratePrivate); 		// import
$pkImportDetails = openssl_pkey_get_details($pkImport); 		// same as getting the public key in previous
$pkImportPublic = $pkImportDetails['key'];
openssl_pkey_free($pkImport); 									// clean up
 echo "\n".$pkGeneratePrivate."\n".$pkGeneratePublic."\n".$pkImportPublic."\n".'Public keys are '.(strcmp($pkGeneratePublic,$pkImportPublic)?'different':'identical').'.';
?>

<?php
$privateKey = openssl_pkey_new(array('private_key_bits' => 2048,'private_key_type' => OPENSSL_KEYTYPE_RSA,));	// generate a 2048 bit rsa private key, returns a php resource, save to file
openssl_pkey_export_to_file($privateKey, '/path/to/privatekey', $passphrase);
$keyDetails = openssl_pkey_get_details($privateKey);			// get the public key $keyDetails['key'] from the private key;
file_put_contents('/path/to/publickey', $keyDetails['key']);
$pubKey = openssl_pkey_get_public('file:///path/to/publickey');
openssl_public_encrypt($sensitiveData, $encryptedData, $pubKey);
$privateKey = openssl_pkey_get_private('file:///path/to/privatekey', $passphrase);	// retrieve $encryptedData from storage ...
openssl_private_decrypt($encryptedData, $sensitiveData, $privateKey);				// load the private key and decrypt the encrypted data
?>


<?php
// Generate
$privateKey = openssl_pkey_new(array('private_key_bits' => 2048,'private_key_type' => OPENSSL_KEYTYPE_RSA,));
openssl_pkey_export_to_file($privateKey, 'private.key');
$a_key = openssl_pkey_get_details($privateKey);
file_put_contents('public.key', $a_key['key']);
openssl_free_key($privateKey);
// Encrypt
$plaintext = 'Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean eleifend vestibulum nunc sit amet mattis. Nulla at volutpat nulla. Pellentesque sodales vel ligula quis consequat. Suspendisse dapibus dolor nec viverra venenatis. Pellentesque blandit vehicula eleifend. Duis eget fermentum velit. Vivamus varius ut dui vel malesuada. Ut adipiscing est non magna posuere ullamcorper. Proin pretium nibh nec elementum tincidunt. Vestibulum leo urna, porttitor et aliquet id, ornare at nibh. Maecenas placerat justo nunc, varius condimentum diam fringilla sed. Donec auctor tellus vitae justo venenatis, sit amet vulputate felis accumsan. Aenean aliquet bibendum magna, ac adipiscing orci venenatis vitae.';
echo 'Plain text: ' . $plaintext;
$plaintext = gzcompress($plaintext);
$publicKey = openssl_pkey_get_public('file:///path/to/public.key');
$a_key = openssl_pkey_get_details($publicKey);
$chunkSize = ceil($a_key['bits'] / 8) - 11;
$output = '';
while ($plaintext)
	{
    $chunk = substr($plaintext, 0, $chunkSize);
    $plaintext = substr($plaintext, $chunkSize);
    $encrypted = '';
    if (!openssl_public_encrypt($chunk, $encrypted, $publicKey))
		{
        die('Failed to encrypt data');
		}
    $output .= $encrypted;
	}
openssl_free_key($publicKey);
$encrypted = $output;
// Decrypt
if (!$privateKey = openssl_pkey_get_private('file:///path/to/private.key'))
	{
    die('Private Key failed');
	}
$a_key = openssl_pkey_get_details($privateKey);
$chunkSize = ceil($a_key['bits'] / 8);
$output = '';
while ($encrypted)
	{
    $chunk = substr($encrypted, 0, $chunkSize);
    $encrypted = substr($encrypted, $chunkSize);
    $decrypted = '';
    if (!openssl_private_decrypt($chunk, $decrypted, $privateKey))
		{
        die('Failed to decrypt data');
		}
    $output .= $decrypted;
	}
openssl_free_key($privateKey);
$output = gzuncompress($output);
echo '<br /><br /> Unencrypted Data: ' . $output;
?>


JS
http://asecuritysite.com/encryption/js05
USARE QUESTA: http://travistidwell.com/jsencrypt/  anche su cdnjs cloudflare

 <script type="text/javascript">
    $(function () {

        //Change the key size value for new keys
        $(".change-key-size").each(function (index, value) {
            var el = $(value);
            var keySize = el.attr('data-value');
            el.click(function (e) {
                var button = $('#key-size');
                button.attr('data-value', keySize);
                button.html(keySize + ' bit <span class="caret"></span>');
                e.preventDefault();
            });
        });

        // Execute when they click the button.
        $('#execute').click(function () {

            // Create the encryption object.
            var crypt = new JSEncrypt();

            // Set the private.
            crypt.setPrivateKey($('#privkey').val());
            //return;
            // If no public key is set then set it here...
            var pubkey = $('#pubkey').val();
            if (!pubkey) {
                $('#pubkey').val(crypt.getPublicKey());
            }

            // Get the input and crypted values.
            var input = $('#input').val();
            var crypted = $('#crypted').val();

            // Alternate the values.
            if (input) {
                $('#crypted').val(crypt.encrypt(input));
                $('#input').val('');
            }
            else if (crypted) {
                var decrypted = crypt.decrypt(crypted);
                if (!decrypted)
                    decrypted = 'This is a test!';
                $('#input').val(decrypted);
                $('#crypted').val('');
            }
        });

        var generateKeys = function () {
            var sKeySize = $('#key-size').attr('data-value');
            var keySize = parseInt(sKeySize);
            var crypt = new JSEncrypt({ default_key_size: keySize });
            var async = $('#async-ck').is(':checked');
            var dt = new Date();
            var time = -(dt.getTime());
            if (async) {
                $('#time-report').text('.');
                var load = setInterval(function () {
                    var text = $('#time-report').text();
                    $('#time-report').text(text + '.');
                }, 500);
                crypt.getKey(function () {
                    clearInterval(load);
                    dt = new Date();
                    time += (dt.getTime());
                    $('#time-report').text('Generated in ' + time + ' ms');
                    $('#privkey').val(crypt.getPrivateKey());
                    $('#pubkey').val(crypt.getPublicKey());
                });
                return;
            }
            crypt.getKey();
            dt = new Date();
            time += (dt.getTime());
            $('#time-report').text('Generated in ' + time + ' ms');
            $('#privkey').val(crypt.getPrivateKey());
            $('#pubkey').val(crypt.getPublicKey());
        };

        // If they wish to generate new keys.
        $('#generate').click(generateKeys);
        generateKeys();
    });
</script>